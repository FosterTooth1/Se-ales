clc,clear, close all;
% Punto 1: Seleccionar una señal univariable de la naturaleza
% En este caso seleccionamos una señal de audio
[y, Fs] = audioread('minion_audio.wav');
y_padded = y(:,1); % Seleccionamos una columna porque es estereo
N = length(y_padded);

N = 2^nextpow2(length(y_padded));
y_padded = [y_noisy; zeros(N-length(y_padded), 1)];

% Punto 3: Aplicar la transformada Rápida de Fourier a dicha señal
% Usar el algoritmo manual y la función fft de MATLAB
Y_manual = manualFFT(y_padded);
Y = fft(y_padded);

% Comparación visual de los espectros de amplitud
f = (0:N-1)*(Fs/N);
amplitude_manual = abs(Y_manual/N);
amplitude = abs(Y/N);

figure;
subplot(2,1,1);
plot(f(1:N), amplitude_manual(1:N));
title('Espectro de Amplitud de la FFT (manual)');
xlabel('Frecuencia (Hz)');
ylabel('Amplitud');

subplot(2,1,2);
plot(f(1:N), amplitude(1:N));
title('Espectro de Amplitud de la FFT (MATLAB)');
xlabel('Frecuencia (Hz)');
ylabel('Amplitud');

% Punto 4: Mostrar gráficamente el espectro de amplitud de la FFT (single)
figure;
plot(f(1:N), amplitude(1:N));
title('Espectro de Amplitud de la FFT');
xlabel('Frecuencia (Hz)');
ylabel('Amplitud');

% Punto 5: Implementar los 4 tipos de filtrado en frecuencia
% Filtro FIR Pasa-Altas con Fc=500Hz
fc_high = 500;
[b_high, a_high] = fir1(48, fc_high/(Fs/2), 'high');
y_high = filter(b_high, a_high, y_padded);

% Filtro FIR Pasa-Bajas con Fc=1000Hz
fc_low = 1000;
[b_low, a_low] = fir1(48, fc_low/(Fs/2), 'low');
y_low = filter(b_low, a_low, y_high);

% Filtro FIR Pasa-Banda con Fc1=500Hz y Fc2=2000Hz
fc1_band = 500;
fc2_band = 2000;
[b_band, a_band] = fir1(48, [fc1_band, fc2_band]/(Fs/2), 'bandpass');
y_band = filter(b_band, a_band, y_low);

% Filtro FIR Rechaza-Banda con Fc1=500Hz y Fc2=2000Hz
[b_notch, a_notch] = fir1(48, [fc1_band, fc2_band]/(Fs/2), 'stop');
y_notch = filter(b_notch, a_notch, y_band);

% Punto 6: Visualizar gráficamente la señal filtrada
figure;
plot(y_notch);
title('Señal con los 4 filtros');
xlabel('Tiempo');
ylabel('Amplitud');

% Punto 7: Visualizar gráficamente la comparación en el dominio del tiempo
figure;
plot(y_padded);
hold on;
plot(y_notch);
title('Comparación en el dominio del tiempo: Original vs Filtrada');
legend('Original', 'Filtrada');
xlabel('Tiempo');
ylabel('Amplitud');

% Punto 8: Visualizar gráficamente la comparación en el dominio de la frecuencia
Y_filtered = manualFFT(y_notch);
amplitude_filtered = abs(Y_filtered/N);

figure;
plot(f(1:N), amplitude(1:N));
hold on;
plot(f(1:N), amplitude_filtered(1:N));
title('Comparación en el dominio de la frecuencia: Original vs Filtrada');
legend('Original', 'Filtrada');
xlabel('Frecuencia (Hz)');
ylabel('Amplitud');

% Función manualFFT para realizar la FFT manualmente
function X = manualFFT(x)
    % Obtenemos la longitud de la señal de entrada
    N = length(x);

    % Aseguramos que la longitu dela señal es una potencia de 2
    if mod(log2(N), 1) ~= 0
        error('La longitud de la señal debe ser una potencia de 2');
    end

    % Llamar a la función recursiva para calcular la FFT
    X = fft_recursive(x);
end

function X = fft_recursive(x)
    % Función recursiva para calcular la FFT

    % Obtener la longitud de la señal de entrada
    N = length(x);

    % Caso base: si N es 1, la FFT es la señal misma
    if N == 1
        X = x;
        return;
    end

    % Dividir la señal en partes par e impar
    x_even = x(1:2:end); % Elementos pares
    x_odd = x(2:2:end);  % Elementos impares

    % Calcular la FFT de las partes par e impar de forma recursiva
    X_even = fft_recursive(x_even);
    X_odd = fft_recursive(x_odd);

    % Prealocar el vector de salida
    X = zeros(N, 1);

    % Calcular los términos de la FFT usando la simetría
    for k = 0:(N/2-1)
        % Calcular el factor de la exponencial compleja
        W_Nk = exp(-2i * pi * k / N);
        
        % Combinar las FFT de las partes par e impar
        X(k+1) = X_even(k+1) + W_Nk * X_odd(k+1);
        X(k+N/2+1) = X_even(k+1) - W_Nk * X_odd(k+1);
    end
end
